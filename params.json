{
  "name": "Honeybee Hive",
  "tagline": "A node module to allow for volunteer computing. Like BOINC but for everyone.",
  "body": "# Honeybee-Hive\r\nMaster [![CircleCI][circleci-image]][circleci-link]\r\nDev [![CircleCI][circleci-dev-image]][circleci-dev-link]\r\n\r\n[![NPM Version][version-image]][npm-link]\r\n[![NPM Download][download-image]][npm-link]\r\n\r\n[![Gitter][gitter-image]][gitter-link]\r\n\r\nA node module to allow for volunteer computing, like BOINC.\r\n\r\n## Install\r\n```bash\r\nnpm install honeybee-hive --save\r\n```\r\n\r\n## Notes\r\n* Alpha stages, expect breaking changes between versions currently\r\n* If you want to have clients from the browser, take a look at [Honeybee-Web](https://github.com/Kurimizumi/Honeybee-Web)\r\n\r\n## Example setups\r\n###Server\r\n* Inline: Work is processed and created inside of your node application\r\n* Subprocess: Work is created and processed inside of another application (can be in another language), and information is passed between the node app and your child process\r\n* Database (not recommended): Work is created and processed by another application, but it is added to a database. The node app finds work in the database and removes it, giving it to the client\r\n\r\n###Client\r\n* Inline: Work is processed inside of the application, and then handed back to the server\r\n* Subprocess: Work is transferred to and from the server by the node application, but processed by a subprocess which is a different application\r\n* Database (not recommended): Work is added to a database, and another client periodically checks the database for new work, and then adds processed work back to the database\r\n\r\n## Usage\r\nSee [examples](https://github.com/Kurimizumi/Honeybee-Hive/tree/master/examples) for working examples, which might be easier to understand\r\n\r\n### Server\r\n#### Start function\r\nThe server gets called like this:\r\n```javascript\r\nlet HoneybeeHive = require('honeybee-hive');\r\nlet eventHandler = HoneybeeHive.Hive(settings);\r\n```\r\n\r\nThe settings object is described below\r\n\r\n#### Settings\r\n```javascript\r\nlet settings = {\r\n  connection: {\r\n    port: 54321 //Listening port, defaults to 54321\r\n  },\r\n  //All in milliseconds\r\n  timeouts: {\r\n    workTimeout: 60000, //Time to wait until a client is assumed to be dead and not completing the work set, allowing someone else to do so. Set to a value less than 1 to disable. Default: 60000\r\n    sessionTimeout: 30000, //Time to wait until a TCP socket which is idle is assumed to be dead and therefore destroyed. Default: 30000\r\n    checkTimeout: 10000, //How often to check for work timeouts. Default: 10000\r\n  },\r\n  work: {\r\n    groupMax: 10 //How many datasets must be submitted before the workgroup is considered completed. Default: 10\r\n  },\r\n  proofOfWork: {\r\n    strength: 4 //How difficult should the proof of work problem be? Higher values help to prevent spam, but take longer to calculate on average. Set to -1 to be (essentially) off. Default: 4\r\n  },\r\n  encryption: {\r\n    key: \"some private key\" //NO DEFAULT. YOU MUST SET THIS. The PEM encoded RSA private key for the server\r\n  },\r\n  sections: {\r\n    disableRegistration: false //Disables registration if this value is true. Default: false\r\n  },\r\n  database: {\r\n    hostname: 'localhost', //Sets the hostname for the mongodb database. Default: localhost\r\n    port: '27017', //Optional. Sets the port for the mongodb databse. Default: none\r\n    databaseName: 'hive' //The name for the mongodb database. You could set this to your project name. Default: hive\r\n  },\r\n  websocket: {\r\n    enabled: false, //Sets if we should also run a WebSocket server for WebSocket clients using Honeybee-Web. Default: false\r\n    port: 54322 //What  port we should run the WebSocket server on. Default: 54322\r\n  }\r\n}\r\n```\r\n\r\n#### Event Emitter\r\nThe main function returns an event emitter which we can then listen on, like this:\r\n```javascript\r\neventHandler.on('eventName', function(eventArgs, eventArgs2) {\r\n  //Some code here to process event arguments\r\n});\r\n```\r\nThe events are detailed below\r\n\r\n###### Create work\r\nWe can listen for requests to create work like this:\r\n```javascript\r\neventHandler.on('create_work', function(callback) {\r\n  //We can send the work to the callback like this:\r\n  callback({\r\n    work: 0\r\n  });\r\n  //Or if there's no work remaining, we can send the callback a null value in JavaScript, like this\r\n  callback(null);\r\n});\r\n```\r\n\r\n###### Workgroup complete\r\nWhen a set of work is complete, we must verify it. We can do so like this:\r\n```javascript\r\neventHandler.on('workgroup_complete', function(array, callback) {\r\n  //Make sure that all the values of the array are equal\r\n  for(let i = 0; i < array.length - 1; i++) {\r\n    //If they aren't equal\r\n    if(array[i] !== array[i+1]) {\r\n      //Then return null to the callback\r\n      callback(null);\r\n    }\r\n  }\r\n  //Otherwise, we can return the first element, since we just want to make sure that there's a consensus\r\n  //You could also return an average, or work backwards on the solution\r\n  callback(array[0]);\r\n});\r\n```\r\n\r\n\r\n###### Datachunk creation\r\nWhen a workgroup is validated, we can then bring it together with other validated workgroups, or datachunks, like this:\r\n```javascript\r\nlet total = 0;\r\neventHandler.on('new_datachunk', function(datachunk) {\r\n  //datachunk is the data that we submitted to the callback for workgroup_complete\r\n  //We access the count property and add it to the total, and then log it to the console\r\n  total += datachunk.count;\r\n  console.log(total);\r\n});\r\n```\r\nRemember that if order matters, then you'll need to submit an order with the work, and form a queue type system\r\n\r\n###### Stopping the server\r\nTo stop the server you can do this:\r\n```javascript\r\neventHandler.stop(function() {\r\n  //Called once all existing connections have finished and the server is actually closed.\r\n});\r\n```\r\n\r\n\r\n###### Notes\r\n\r\n* Progress is not saved. It's advisable that when you create work that you somehow store the work that has been created and what hasn't. Once work is created, it will be distributed to clients, but otherwise there is no way for you to know what work needs to be created still.\r\n\r\n### Client\r\n#### Start function\r\nThe client gets called like this:\r\n```javascript\r\nlet HoneybeeHive = require('honeybee-hive');\r\nHoneybeeHive.Honeybee(settings, function(eventHandler) {\r\n  //Wait for us to be registered\r\n  eventHandler.once('registered', function() {\r\n    //Request our first piece of work\r\n    eventHandler.request(workHandler);\r\n  })\r\n});\r\n```\r\n\r\nThe settings object is described below\r\n\r\n#### Settings\r\n```javascript\r\nlet settings = {\r\n  connection: {\r\n    hostname: 'localhost', //The hostname the server is listening on, defaults to localhost\r\n    port: 54321 //Listening port, defaults to 54321\r\n  },\r\n  encryption: {\r\n    key: \"some public key\" //NO DEFAULT. YOU MUST SET THIS. The PEM encoded RSA public key for the server\r\n  }\r\n}\r\n```\r\n\r\n#### Event Handler\r\nThe main function returns an event handler which we can then call, like this:\r\n```javascript\r\neventHandler.functionName(callback);\r\n```\r\nThe callbacks and events are detailed below\r\n\r\n###### Ready\r\nWe know that the client is ready to process work when the registered event is fired. We can listen to this by doing:\r\n```javascript\r\neventHandler.once('registered', function() {\r\n  //Request work here\r\n});\r\n```\r\n\r\n###### Request work\r\nWe can request work like this:\r\n```javascript\r\neventHandler.request(function(error, work) {\r\n  //If error is true, then we can process it as needed\r\n  //work is the work that we specified on the server\r\n  //we should process it and then send it for submission\r\n});\r\n```\r\n\r\n###### Submit work\r\nWe can submit processed work like this:\r\n```javascript\r\neventHandler.submit(work, function(error, success) {\r\n  //If error is true then we can process it as needed\r\n  //success tells us if the submission was successful. You should not retry on failure, rather just request new work\r\n});\r\n```\r\n\r\n* work is the processed work that we wish to submit to the server\r\n\r\n###### Combining the two\r\nWe can combine requesting and submitting like this:\r\n```javascript\r\nfunction workHandler(error, work) {\r\n  eventHandler.submit(work, submitHandler);\r\n}\r\nfunction submitHandler(error, success) {\r\n  eventHandler.request(workHandler);\r\n}\r\n//Request first work\r\neventHandler.request(workHandler);\r\n```\r\n\r\n#### Error handling\r\nAs you can see in the above examples, there are areas where an error object is returned.\r\n\r\nYou can do something similar to a try/catch block in Java with if statements, importing the error objects. E.g.:\r\n```javascript\r\nconst HoneybeeHive = require('honeybee-hive');\r\nconst errorList = HoneybeeHive.errorList;\r\nconst errorGroups = HoneybeeHive.errorGroups;\r\nfunction workHandler(error, work) {\r\n  if(error) {\r\n    //Start try/catch-esque if/else if/else block\r\n    //Catch all security errors\r\n    if(error instanceof errorGroups.SecurityError) {\r\n      //Do something here\r\n    }\r\n    //Catch only post handshake errors\r\n    else if(error instanceof errorList.HandshakePostCompleteFailure) {\r\n      //Do something\r\n    }\r\n    //Catch all *other* handshake errors\r\n    else if(error instanceof errorGroups.HandshakeError) {\r\n      //Do something\r\n    }\r\n    //Catch either submit or request errors\r\n    else if(error instanceof errorGroups.SubmitError || error instanceof errorGroups.RequestError) {\r\n      //Do something\r\n    }\r\n    //Catch all other errors, including generic/unknown errors\r\n    else {\r\n      //Do something\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nThis is the complete list of errors, their description, and their error group:\r\n\r\n| Error Name                        | Error Group       | Error Description                                                                                                        |\r\n|-----------------------------------|-------------------|--------------------------------------------------------------------------------------------------------------------------|\r\n| DatabaseGeneric                   | DatabaseError     | Generic database errors which do not have a specific error associated                                                    |\r\n| DatabaseNotFound                  | DatabaseError     | When a record was not found in the database (e.g. when the worker was not found as being a worker for the submitted data |\r\n| GenericPayloadMissing             | GenericError      | When the encrypted payload is missing                                                                                    |\r\n| GenericParametersMissing          | GenericError      | When parameters are missing (e.g. the type of message)                                                                   |\r\n| GenericSecurityInformationMissing | GenericError      | When security information is missing (e.g. the IV used to encrypt the payload)                                           |\r\n| HandshakeGeneric                  | HandshakeError    | When a generic handshake error occurs                                                                                    |\r\n| HandshakeKeyMissing               | HandshakeError    | When the client doesn't provide an AES key                                                                               |\r\n| HandshakePostCompleteFailure      | HandshakeError    | When the handshake fails elsewhere (e.g. someone edits the packets and fails to match the authentication tag)            |\r\n| VerificationGeneric               | VerificationError | When a generic verification error occurs                                                                                 |\r\n| VerificationNotExecuted           | VerificationError | When a user tries to execute an operation which requires verification, but they have not verified themselves yet         |\r\n| RequestNoWork                     | RequestError      | When a user tries to request work, but there is none remaining for the server to give out                                |\r\n| RequestPendingWork                | RequestError      | When a user tries to request work, but has work which is unsubmitted                                                     |\r\n| SubmitNoData                      | SubmitError       | When a user sends no completed work with the submission                                                                  |\r\n| SecurityInvalidKey                | SecurityError     | When an invalid key format is sent                                                                                       |\r\n| SecurityKeyGenerationFailure      | SecurityError     | When an RSA keypair fails to generate                                                                                    |\r\n| SecurityEncryptionFailure         | SecurityError     | When there's an error encrypting                                                                                         |\r\n| SecurityDecryptionFailure         | SecurityError     | When there's an error decrypting                                                                                         |\r\n| SecuritySigningFailure            | SecurityError     | When there's an error signing the message                                                                                |\r\n| SecurityVerificationFailure       | SecurityError     | When there's an error when trying to verify a message                                                                    |\r\n\r\n\r\n\r\n###### Notes\r\n\r\n* Progress is not saved. It's advisable that when you receive work that you save it for processing later, and also record the time of the request in order to avoid DATABASE_NOT_FOUND errors on the client\r\n\r\n## License\r\n[ISC][license-link]\r\n\r\n[license-link]: https://github.com/Kurimizumi/Honeybee-Hive/blob/master/LICENSE.md\r\n[gitter-image]: https://img.shields.io/gitter/room/Kurimizumi/Honeybee-Hive.svg\r\n[gitter-link]: https://gitter.im/Honeybee-Hive/Lobby?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge\r\n[circleci-image]: https://circleci.com/gh/Kurimizumi/Honeybee-Hive/tree/master.svg?&style=shield\r\n[circleci-link]: https://circleci.com/gh/Kurimizumi/Honeybee-Hive/tree/master\r\n[circleci-dev-image]: https://circleci.com/gh/Kurimizumi/Honeybee-Hive/tree/dev.svg?style=shield\r\n[circleci-dev-link]: https://circleci.com/gh/Kurimizumi/Honeybee-Hive/tree/dev\r\n[npm-link]: https://npmjs.org/package/honeybee-hive\r\n[version-image]: https://img.shields.io/npm/v/honeybee-hive.svg\r\n[download-image]: https://img.shields.io/npm/dm/honeybee-hive.svg\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}