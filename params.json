{
  "name": "Honeybee Hive",
  "tagline": "A node module to allow for volunteer computing. Like BOINC but for everyone.",
  "body": "# Honeybee-Hive\r\n[![CircleCI][circleci-image]][circleci-link]\r\n[![NPM Version][version-image]][npm-link]\r\n[![NPM Download][download-image]][npm-link]\r\n\r\nA node module to allow for volunteer computing, like BOINC.\r\n\r\n## Install\r\n```bash\r\nnpm install honeybee-hive --save\r\n```\r\n\r\n## Notes\r\n* Alpha stages, expect breaking changes between versions currently\r\n\r\n## Example setups\r\n###Server\r\n* Inline: Work is processed and created inside of your node application\r\n* Subprocess: Work is created and processed inside of another application (can be in another language), and information is passed between the node app and your child process\r\n* Database (not recommended): Work is created and processed by another application, but it is added to a database. The node app finds work in the database and removes it, giving it to the client\r\n\r\n###Client\r\n* Inline: Work is processed inside of the application, and then handed back to the server\r\n* Subprocess: Work is transferred to and from the server by the node application, but processed by a subprocess which is a different application\r\n* Database (not recommended): Work is added to a database, and another client periodically checks the database for new work, and then adds processed work back to the database\r\n\r\n## Usage\r\nSee [examples](https://github.com/Kurimizumi/Honeybee-Hive/tree/master/examples) for working examples, which might be easier to understand\r\n\r\n### Server\r\n#### Start function\r\nThe server gets called like this:\r\n```javascript\r\nvar HoneybeeHive = require('honeybee-hive');\r\nvar eventEmitter = HoneybeeHive.Hive(settings);\r\n```\r\n\r\nThe settings object is described below\r\n\r\n#### Settings\r\n```javascript\r\nvar settings = {\r\n  connection: {\r\n    port: 54321 //Listening port, defaults to 54321\r\n  },\r\n  //All in milliseconds\r\n  timeouts: {\r\n    workTimeout: 60000, //Time to wait until a client is assumed to be dead and not completing the work set, allowing someone else to do so. Set to a value less than 1 to disable. Default: 60000\r\n    sessionTimeout: 30000, //Time to wait until a TCP socket which is idle is assumed to be dead and therefore destroyed. Default: 30000\r\n    checkTimeout: 10000, //How often to check for work timeouts. Default: 10000\r\n  },\r\n  work: {\r\n    groupMax: 10 //How many datasets must be submitted before the workgroup is considered completed. Default: 10\r\n  },\r\n  encryption: {\r\n    key: \"some private key\" //NO DEFAULT. YOU MUST SET THIS. The PEM encoded RSA private key for the server\r\n  },\r\n  sections: {\r\n    disableRegistration: false //Disables registration if this value is true. Default: false\r\n  }\r\n}\r\n```\r\n\r\n#### Event Emitter\r\nThe main function returns an event emitter which we can then listen on, like this:\r\n```javascript\r\neventEmitter.on('eventName', function(eventArgs, eventArgs2) {\r\n  //Some code here to process event arguments\r\n});\r\n```\r\nThe events are detailed below\r\n\r\n###### Create work\r\nWe can listen for requests to create work like this:\r\n```javascript\r\neventEmitter.on('create_work', function(callback) {\r\n  //We can send the work to the callback like this:\r\n  callback({\r\n    work: 0\r\n  });\r\n  //Or if there's no work remaining, we can send the callback a null value in JavaScript, like this\r\n  callback(null);\r\n});\r\n```\r\n\r\n###### Workgroup complete\r\nWhen a set of work is complete, we must verify it. We can do so like this:\r\n```javascript\r\neventEmitter.on('workgroup_complete', function(array, callback) {\r\n  //Make sure that all the values of the array are equal\r\n  for(var i = 0; i < array.length - 1; i++) {\r\n    //If they aren't equal\r\n    if(array[i] !== array[i+1]) {\r\n      //Then return null to the callback\r\n      callback(null);\r\n    }\r\n  }\r\n  //Otherwise, we can return the first element, since we just want to make sure that there's a consensus\r\n  //You could also return an average, or work backwards on the solution\r\n  callback(array[0]);\r\n});\r\n```\r\n\r\n\r\n###### Datachunk creation\r\nWhen a workgroup is validated, we can then bring it together with other validated workgroups, or datachunks, like this:\r\n```javascript\r\nvar total = 0;\r\neventEmitter.on('new_datachunk', function(datachunk) {\r\n  //datachunk is the data that we submitted to the callback for workgroup_complete\r\n  //We access the count property and add it to the total, and then log it to the console\r\n  total += datachunk.count;\r\n  console.log(total);\r\n});\r\n```\r\n\r\nRemember that if order matters, then you'll need to submit an order with the work, and form a queue type system\r\n\r\n###### Notes\r\n\r\n* Progress is not saved. It's advisable that when you create work that you somehow store the work that has been created and what hasn't. Once work is created, it will be distributed to clients, but otherwise there is no way for you to know what work needs to be created still.\r\n\r\n### Client\r\n#### Start function\r\nThe client gets called like this:\r\n```javascript\r\nvar HoneybeeHive = require('honeybee-hive');\r\nvar eventHandler;\r\nHoneybeeHive.Honeybee(settings, function(evtHandler) {\r\n  //Set eventHandler to evtHandler\r\n  eventHandler = evtHandler;\r\n  //Wait for us to be registered\r\n  eventHandler.once('registered', function() {\r\n    //Request our first piece of work\r\n    eventHandler.request(workHandler);\r\n  })\r\n});\r\n```\r\n\r\nThe settings object is described below\r\n\r\n#### Settings\r\n```javascript\r\nvar settings = {\r\n  connection: {\r\n    hostname: 'localhost', //The hostname the server is listening on, defaults to localhost\r\n    port: 54321 //Listening port, defaults to 54321\r\n  },\r\n  encryption: {\r\n    key: \"some public key\" //NO DEFAULT. YOU MUST SET THIS. The PEM encoded RSA public key for the server\r\n  }\r\n}\r\n```\r\n\r\n#### Event Handler\r\nThe main function returns an event handler which we can then call, like this:\r\n```javascript\r\neventHandler.functionName(callback);\r\n```\r\nThe callbacks and events are detailed below\r\n\r\n###### Ready\r\nWe know that the client is ready to process work when the registered event is fired. We can listen to this by doing:\r\n```javascript\r\neventHandler.once('registered', function() {\r\n  //Request work here\r\n});\r\n```\r\n\r\n###### Request work\r\nWe can request work like this:\r\n```javascript\r\neventHandler.request(function(work) {\r\n  //work is the work that we specified on the server\r\n  //we should process it and then send it for submission\r\n});\r\n```\r\n\r\n###### Submit work\r\nWe can submit processed work like this:\r\n```javascript\r\neventHandler.submit(work, function(success) {\r\n  //success tells us if the submission was successful. You should not retry on failure, rather just request new work\r\n});\r\n```\r\n\r\n* work is the processed work that we wish to submit to the server\r\n\r\n###### Combining the two\r\nWe can combine requesting and submitting like this:\r\n```javascript\r\nfunction workHandler(work) {\r\n  eventHandler.submit(work, submitHandler);\r\n}\r\nfunction submitHandler(success) {\r\n  eventHandler.request(workHandler);\r\n}\r\n//Request first work\r\neventHandler.request(workHandler);\r\n```\r\n\r\n\r\n###### Notes\r\n\r\n* Progress is not saved. It's advisable that when you receive work that you save it for processing later, and also record the time of the request in order to avoid DATABASE_NOT_FOUND errors on the client\r\n\r\n## License\r\n[ISC][license-link]\r\n\r\n[license-link]: https://github.com/Kurimizumi/Honeybee-Hive/blob/master/LICENSE.md\r\n[circleci-image]: https://circleci.com/gh/Kurimizumi/Honeybee-Hive.svg?&style=shield\r\n[circleci-link]: https://circleci.com/gh/Kurimizumi/Honeybee-Hive\r\n[npm-link]: https://npmjs.org/package/honeybee-hive\r\n[version-image]: https://img.shields.io/npm/v/honeybee-hive.svg\r\n[download-image]: https://img.shields.io/npm/dm/honeybee-hive.svg\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}